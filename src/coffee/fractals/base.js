// Generated by CoffeeScript 1.6.3
(function() {
  WebFract3D.Fractals.Base = (function() {
    function Base(view_state, fractal_state) {
      this.points = [];
      this.depths = [];
      this.view_state = view_state;
      this.fractal_state = fractal_state;
      this.max_iterations = 0;
      this.min_iterations = 10000;
      this.run();
    }

    Base.prototype.quittingDistance = 0.01;

    Base.prototype.calculate = function() {
      if (!this.alerted) {
        alert("Base fractal doesn't implement calculate");
      }
      return this.alerted = true;
    };

    Base.prototype.run = function() {
      var i, inc, iterations, r, x, y, zi, zr, _i, _j, _ref, _ref1, _ref2, _results;
      inc = this.fractal_state.size / this.fractal_state.divisions;
      i = this.fractal_state.i - this.fractal_state.size / 2;
      _results = [];
      for (y = _i = 0, _ref = this.fractal_state.divisions; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        this.points.push([]);
        r = this.fractal_state.r - this.fractal_state.size / 2;
        for (x = _j = 0, _ref1 = this.fractal_state.divisions; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.calculate(r, i, this.fractal_state), iterations = _ref2[0], zr = _ref2[1], zi = _ref2[2];
          this.points[y].push([iterations, zr, zi]);
          if (iterations > this.max_iterations) {
            this.max_iterations = iterations;
          }
          if (iterations < this.min_iterations) {
            this.min_iterations = iterations;
          }
          r += inc;
        }
        _results.push(i += inc);
      }
      return _results;
    };

    Base.prototype.complexDivision = function(numR, numI, denR, denI) {
      var divisor;
      divisor = denR * denR + denI * denI;
      return [(numR * denR + numI * denI) / divisor, (numI * denR - numR * denI) / divisor];
    };

    Base.prototype.complexDistance = function(r1, i1, r2, i2) {
      var i, r;
      r = r1 - r2;
      i = i1 - i2;
      return Math.sqrt(r * r + i * i);
    };

    Base.prototype.complexMultiplication = function(r1, i1, r2, i2) {
      return [r1 * r2 - i1 * i2, r1 * i2 + r2 * i1];
    };

    return Base;

  })();

}).call(this);
