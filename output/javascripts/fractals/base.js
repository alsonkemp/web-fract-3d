// Generated by CoffeeScript 1.6.3
(function() {
  WebFract3D.Fractals.Base = (function() {
    function Base(view_state_service, fractal_state_service) {
      this.points = [];
      this.depths = [];
      this.view_state = view_state_service.state;
      this.fractal_state = fractal_state_service.state;
      this.max_iterations = 0;
      this.min_iterations = 10000;
      this.run();
    }

    Base.prototype.quittingDistance = 0.01;

    Base.prototype.calculate = function() {
      if (!this.alerted) {
        alert("Base fractal doesn't implement calculate");
      }
      return this.alerted = true;
    };

    Base.prototype.run = function() {
      var i, inc, iterations, r, x, y, zi, zr, _i, _j, _ref, _ref1, _ref2, _results;
      inc = this.fractal_state.size / this.fractal_state.divisions;
      i = this.fractal_state.i - this.fractal_state.size / 2;
      _results = [];
      for (y = _i = 0, _ref = this.fractal_state.divisions; 0 <= _ref ? _i <= _ref : _i >= _ref; y = 0 <= _ref ? ++_i : --_i) {
        this.points.push([]);
        r = this.fractal_state.r - this.fractal_state.size / 2;
        for (x = _j = 0, _ref1 = this.fractal_state.divisions; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; x = 0 <= _ref1 ? ++_j : --_j) {
          _ref2 = this.calculate(r, i, this.fractal_state), iterations = _ref2[0], zr = _ref2[1], zi = _ref2[2];
          this.points[y].push([iterations, zr, zi]);
          if (iterations > this.max_iterations) {
            this.max_iterations = iterations;
          }
          if (iterations < this.min_iterations) {
            this.min_iterations = iterations;
          }
          r += inc;
        }
        _results.push(i += inc);
      }
      return _results;
    };

    Base.prototype.complexDivision = function(numR, numI, denR, denI) {
      var divisor;
      divisor = denR * denR + denI * denI;
      return [(numR * denR + numI * denI) / divisor, (numI * denR - numR * denI) / divisor];
    };

    Base.prototype.complexDistance = function(r1, i1, r2, i2) {
      var i, r;
      r = r1 - r2;
      i = i1 - i2;
      return Math.sqrt(r * r + i * i);
    };

    Base.prototype.complexMultiplication = function(r1, i1, r2, i2) {
      return [r1 * r2 - i1 * i2, r1 * i2 + r2 * i1];
    };

    Base.prototype.makePoles = function(num) {
      var n, poles, rot, _i;
      poles = [];
      for (n = _i = 0; 0 <= num ? _i < num : _i > num; n = 0 <= num ? ++_i : --_i) {
        rot = 2 * Math.PI * n / num;
        poles.push([Math.cos(rot), Math.sin(rot)]);
      }
      return poles;
    };

    Base.prototype.depthFunction = function(iter) {
      return this.view_state.size * (0.5 - Math.log(iter + 1 - this.min_iterations) / Math.log(this.max_iterations - this.min_iterations));
    };

    Base.prototype.mandelColorFunction = function(iter) {
      if (iter === this.fractal_state.max_iterations) {
        return [0, 0, 0];
      } else if (iter % 120 < 20) {
        return [0.2 + (iter % 120) / 25.0, 0, 0];
      } else if (((iter % 120) >= 20) && ((iter % 120) < 40)) {
        return [1, 0.2 + (iter % 120) / 25, 0, 0];
      } else if (((iter % 120) >= 40) && ((iter % 120) < 60)) {
        return [1.0 - ((iter % 120) - 40) / 20, 1, 0];
      } else if (((iter % 120) >= 60) && ((iter % 120) < 80)) {
        return [0, 1, 0.2 + ((iter % 120) - 60) / 25];
      } else if (((iter % 120) >= 80) && ((iter % 120) < 100)) {
        return [0, 1 - ((iter % 120) - 80) / 20, 1];
      } else {
        return [0, 0, 1 - ((iter % 120) - 100) / 20];
      }
    };

    Base.prototype.newtonColors = [[0.0, 0.0, 0.0], [1.0, 0.0, 0.0], [0.0, 1.0, 0.0], [0.0, 0.0, 1.0], [1.0, 1.0, 0.0], [0.0, 1.0, 1.0], [1.0, 0.0, 1.0], [1.0, 1.0, 0.5], [0.5, 1.0, 1.0], [1.0, 0.5, 1.0], [0.7, 0.7, 1.0]];

    Base.prototype.newtonCloseDistance = 0.01;

    Base.prototype.newtonColorFunction = function(iter, zr, zi) {
      var i, idx, p, r, _i, _len, _ref;
      _ref = this.poles;
      for (idx = _i = 0, _len = _ref.length; _i < _len; idx = ++_i) {
        p = _ref[idx];
        r = p[0] - zr;
        i = p[1] - zi;
        if (Math.sqrt(r * r + i * i) < this.newtonCloseDistance) {
          return this.newtonColors[idx + 1];
        }
      }
      return this.newtonColors[0];
    };

    return Base;

  })();

}).call(this);
