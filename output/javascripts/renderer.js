// Generated by CoffeeScript 1.6.3
(function() {
  WebFract3D.factory("RendererService", function($rootScope, $location, ViewStateService, FractalStateService) {
    var geometry, onWindowResize,
      _this = this;
    onWindowResize = function() {
      _this.camera.aspect = window.innerWidth / window.innerHeight;
      _this.camera.updateProjectionMatrix();
      return _this.webgl_renderer.setSize(window.innerWidth, window.innerHeight);
    };
    this.recalc = function() {
      if (!FractalStateService.state.fractal) {
        return;
      }
      _this.fractal = new WebFract3D.Fractals[FractalStateService.state.fractal](ViewStateService, FractalStateService);
      _this.scene.remove(_this.mesh);
      _this.mesh = _this.getNewMesh();
      _this.scene.add(_this.mesh);
      _this.redraw();
      return $location.search(FractalStateService.state);
    };
    this.redraw = function() {
      var v, vss, _i, _len, _ref;
      vss = ViewStateService.state;
      _ref = ['x', 'y', 'z'];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        v = _ref[_i];
        _this.mesh.rotation[v] = vss.rotation[v] / 180 * Math.PI;
        _this.camera.position[v] = vss.position[v];
      }
      return _this.webgl_renderer.render(_this.scene, _this.camera);
    };
    this.getNewMesh = function() {
      var aspect_ratio, buildVertex, f, fss, geometry, points, v, vss, x, xinc, xmin, y, yinc, ymin, _i, _j, _ref, _ref1, _x, _y,
        _this = this;
      fss = FractalStateService.state;
      vss = ViewStateService.state;
      geometry = new THREE.Geometry();
      aspect_ratio = (window.innerWidth - 300) / window.innerHeight;
      ymin = vss.size / -2;
      yinc = vss.size / fss.divisions;
      xmin = ymin * aspect_ratio;
      xinc = yinc * aspect_ratio;
      y = ymin;
      v = 0;
      points = this.fractal.points;
      for (_y = _i = 1, _ref = fss.divisions; 1 <= _ref ? _i <= _ref : _i >= _ref; _y = 1 <= _ref ? ++_i : --_i) {
        x = xmin;
        for (_x = _j = 1, _ref1 = fss.divisions; 1 <= _ref1 ? _j <= _ref1 : _j >= _ref1; _x = 1 <= _ref1 ? ++_j : --_j) {
          buildVertex = function(dx, dy) {
            var c, d, i, zi, zr, _ref2;
            _ref2 = points[_y + dy][_x + dx], i = _ref2[0], zr = _ref2[1], zi = _ref2[2];
            d = _this.fractal.depthFunction(i);
            geometry.vertices.push(new THREE.Vector3(x + dx * xinc, y + dy * yinc, d));
            c = new THREE.Color('0xffffff');
            c.setRGB.apply(c, _this.fractal.colorFunction(i, zr, zi));
            return f.vertexColors.push(c);
          };
          f = new THREE.Face3(v++, v++, v++);
          buildVertex(-1, -1);
          buildVertex(0, -1);
          buildVertex(-1, 0);
          geometry.faces.push(f);
          f = new THREE.Face3(v++, v++, v++);
          buildVertex(0, 0);
          buildVertex(-1, 0);
          buildVertex(0, -1);
          geometry.faces.push(f);
          x += xinc;
        }
        y += yinc;
      }
      return new THREE.Mesh(geometry, new THREE.MeshBasicMaterial({
        side: THREE.DoubleSide,
        vertexColors: THREE.VertexColors
      }));
    };
    this.webgl_renderer = new THREE.WebGLRenderer({
      canvas: $('#canvas')[0]
    });
    this.webgl_renderer.setSize(window.innerWidth - 300, window.innerHeight);
    this.camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 1, 2000);
    geometry = new THREE.Geometry();
    this.mesh = new THREE.Mesh(geometry);
    this.scene = new THREE.Scene();
    this.scene.add(this.mesh);
    this.scene.add(this.camera);
    window.addEventListener("resize", this.onWindowResize, false);
    $rootScope.$watch("FractalStateService.state", this.recalc, true);
    $rootScope.$watch("ViewStateService.state", this.redraw, true);
    return this;
  });

}).call(this);
